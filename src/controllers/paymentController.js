const User = require('../models/User');
const { Markup } = require('telegraf');
const { checkAdmin } = require('../utils/auth');
const { formatDate, escapeMarkdown } = require('../utils/helpers');
const { createVpnClient } = require('../services/vpnService');
const fs = require('fs');
const path = require('path');

/**
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º —Å–∫—Ä–∏–Ω—à–æ—Ç –æ–ø–ª–∞—Ç—ã.
 */
exports.handlePhoto = async (ctx) => {
  const { id, first_name, username } = ctx.from;

  if (id === parseInt(process.env.ADMIN_ID)) {
    return ctx.reply('–í—ã –≤ —Ä–µ–∂–∏–º–µ –∞–¥–º–∏–Ω–∞, —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –Ω–µ —Ç—Ä–µ–±—É—é—Ç—Å—è.');
  }

  const photo = ctx.message.photo.pop();

  try {
    await User.findOneAndUpdate(
      { userId: id },
      {
        userId: id,
        username: username || first_name,
        firstName: first_name,
        paymentPhotoId: photo.file_id,
        paymentPhotoDate: new Date(),
        status: 'pending'
      },
      { upsert: true, new: true }
    );

    const keyboard = Markup.inlineKeyboard([
      Markup.button.callback('‚úÖ –ü—Ä–∏–Ω—è—Ç—å', `approve_${id}`),
      Markup.button.callback('‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å', `reject_${id}`)
    ]);

    let userDisplay = '';
    const safeFirstName = escapeMarkdown(first_name || '–ù–µ —É–∫–∞–∑–∞–Ω–æ');

    if (username) {
      userDisplay = `${safeFirstName} (@${escapeMarkdown(username)})`;
    } else {
      userDisplay = `${safeFirstName} (–±–µ–∑ username)`;
    }

    await ctx.telegram.sendPhoto(
      process.env.ADMIN_ID,
      photo.file_id,
      {
        caption: `üì∏ *–ù–æ–≤—ã–π –ø–ª–∞—Ç—ë–∂ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:*\n–ò–º—è: ${userDisplay}\nID: ${id}`,
        parse_mode: 'Markdown',
        ...keyboard
      }
    );

    await ctx.reply('‚úÖ –°–∫—Ä–∏–Ω—à–æ—Ç –ø–æ–ª—É—á–µ–Ω! –ê–¥–º–∏–Ω –ø—Ä–æ–≤–µ—Ä–∏—Ç –µ–≥–æ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.');
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–æ—Ç–æ:', error);
    await ctx.reply('‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞.');
  }
};

/**
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–¥–æ–±—Ä–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ–Ω—Ñ–∏–≥ + –≤–∏–¥–µ–æ–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é
 */
exports.handleApprove = async (ctx) => {
  if (!checkAdmin(ctx)) {
    return ctx.answerCbQuery('üö´ –¢–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∞');
  }

  const userId = parseInt(ctx.match[1]);

  try {
    const user = await User.findOne({ userId });
    let newExpireDate = new Date();

    if (user?.expireDate > new Date()) {
      newExpireDate = new Date(user.expireDate);
    }

    newExpireDate.setMonth(newExpireDate.getMonth() + 1);
    newExpireDate.setHours(23, 59, 59, 999);

    const updatedUser = await User.findOneAndUpdate(
      { userId },
      {
        status: 'active',
        expireDate: newExpireDate,
        paymentPhotoId: null,
        paymentPhotoDate: null,
        $inc: { subscriptionCount: 1 }
      },
      { new: true }
    );

    await ctx.answerCbQuery('‚úÖ –ü–ª–∞—Ç—ë–∂ –ø—Ä–∏–Ω—è—Ç');
    await ctx.deleteMessage();

    if (updatedUser.subscriptionCount === 1) {
      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ñ–∏–≥–∞
      const clientName = user.username 
        ? user.username.replace(/[^a-zA-Z0-9_]/g, '') 
        : `user_${userId}`;
      
      const configContent = await createVpnClient(clientName);
      
      // –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
      await ctx.telegram.sendDocument(
        userId,
        { source: Buffer.from(configContent), filename: `${clientName}.conf` },
        { caption: 'üîê –í–∞—à –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ñ–∞–π–ª –¥–ª—è VPN' }
      );

      // –û—Ç–ø—Ä–∞–≤–∫–∞ –≤–∏–¥–µ–æ–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
      const videoPath = path.join(__dirname, '../../src/videos/instruction.mp4');
      
      if (fs.existsSync(videoPath)) {
        await ctx.telegram.sendVideo(
          userId,
          { source: fs.createReadStream(videoPath) },
          {
            caption: 'üé• –í–∏–¥–µ–æ–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ:',
            parse_mode: 'Markdown'
          }
        );
      } else {
        console.error('–í–∏–¥–µ–æ–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞:', videoPath);
        await ctx.telegram.sendMessage(
          process.env.ADMIN_ID,
          '‚ö†Ô∏è –§–∞–π–ª –≤–∏–¥–µ–æ–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω!'
        );
      }

      // –ö–Ω–æ–ø–∫–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
      await ctx.telegram.sendMessage(
        userId,
        '–ü–æ—Å–ª–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ:',
        Markup.inlineKeyboard([
          [
            Markup.button.callback('‚úÖ –í—Å—ë —Ä–∞–±–æ—Ç–∞–µ—Ç', `vpn_configured_${userId}`),
            Markup.button.callback('‚ùå –ü—Ä–æ–±–ª–µ–º—ã', `vpn_failed_${userId}`)
          ]
        ])
      );
    } else {
      await ctx.telegram.sendMessage(
        userId,
        `üéâ –ü–æ–¥–ø–∏—Å–∫–∞ –ø—Ä–æ–¥–ª–µ–Ω–∞ –¥–æ ${formatDate(newExpireDate, true)}!`,
        { parse_mode: 'Markdown' }
      );
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–¥–æ–±—Ä–µ–Ω–∏–∏ –ø–ª–∞—Ç–µ–∂–∞:', error);
    await ctx.answerCbQuery('‚ö†Ô∏è –û—à–∏–±–∫–∞!');
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–ª–∞—Ç–µ–∂–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.');
  }
};

/**
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞
 */
exports.handleReject = async (ctx) => {
  if (!checkAdmin(ctx)) {
    return ctx.answerCbQuery('üö´ –¢–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∞');
  }

  const userId = parseInt(ctx.match[1]);

  try {
    await User.findOneAndUpdate(
      { userId },
      {
        status: 'rejected',
        paymentPhotoId: null,
        paymentPhotoDate: null
      }
    );

    await ctx.telegram.sendMessage(
      userId,
      '‚ùå –ü–ª–∞—Ç—ë–∂ –æ—Ç–∫–ª–æ–Ω—ë–Ω. –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n' +
      '- –ù–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞\n- –ù–µ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è\n- –ù–µ—á–∏—Ç–∞–µ–º—ã–π —Å–∫—Ä–∏–Ω—à–æ—Ç\n\n' +
      '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —á–µ–∫ –µ—â—ë —Ä–∞–∑.',
      { parse_mode: 'Markdown' }
    );

    await ctx.answerCbQuery('‚ùå –ü–ª–∞—Ç—ë–∂ –æ—Ç–∫–ª–æ–Ω—ë–Ω');
    await ctx.deleteMessage();
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏ –ø–ª–∞—Ç–µ–∂–∞:', error);
    await ctx.answerCbQuery('‚ö†Ô∏è –û—à–∏–±–∫–∞!');
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏ –ø–ª–∞—Ç–µ–∂–∞.');
  }
};